<!--
`rpg-entity` is the custom element that represents a playable entity.

Example:
    <rpg-entity type="player"></rpg-entity>


@element rpg-entity
@blurb This is the custom element that represents a playable entity.
@author Wassim Chegham
-->
<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../rpg-avatar/rpg-avatar.html">

<polymer-element name="rpg-entity">
  <template>
	  <link rel="stylesheet" href="../../styles/sprites/explosion.css">
	  <link rel="stylesheet" href="../../styles/animations/animations.css">
	  <link rel="stylesheet" href="http://localhost:1337/styles/animations/remote-animations.css">
	  <link rel="stylesheet" href="rpg-entity.css">
	  <div class="entity-template" id="entity-template">
	  	<span class="rpg-life"><i style="width:{{life.current/10}}%;"></i></span>
	  	<span class="rpg-name">{{name}}</span>
	  	
	  	<rpg-avatar class="avatar" avatar="{{avatar_content}}" is-uri="{{avatar_is_uri}}"></rpg-avatar>
	  	
	  	<span id="states-container" class="effects-sprite-explosion"></span>
	  	<span class="hit">-{{amount}}</span>
	  	<span class="debug-info" id="debug-info">
				life: {{life.current}}<br>
				p1: {{position.current.x}},{{position.current.y}}<br>
				p2: {{position.previous.x}},{{position.previous.y}}<br>
	  	</span>
	  </div>
	</template>
  <script>
  	var entity;
    Polymer({
    	publish : {
    		'type': 'player',
    		'name': 'player', 
    		'life': {
    			current: 1000,
    			max: 1000
    		},
    		'avatar': {
    			name: ''
    		},
    		'position': {
    			current: {x:0, y:0},
    			previous: {x:0, y:0},
    		},
	    	debug: false,
	    	avatar_content: null
    	},
    	debugChanged: function(oldValue, newValue){
    		this.$['debug-info'].classList.toggle('show-debug');
    	},
    	typeChanged: function(oldValue, newValue){
    		
    	},
    	positionChanged: function(oldValue, newValue){
    		entity.position.current.x = newValue;
    	},
    	nameChanged: function(oldValue, newValue){
    		entity.name = newValue;
    	},
    	avatarChanged: function(oldValue, newValue){
    		this.avatar_content = newValue.name;
    		this.avatar_is_uri = false;
    		if(newValue['@c'] && newValue['@c'].indexOf('ServerImage') !== -1){
    			this.avatar_is_uri = true;
    			this.avatar_content = 'data:image/png;base64,'+newValue.content;
    		}
    		entity.avatar = this.avatar_content;
    	},
    	lifeChanged: function(oldValue, newValue){
    		entity.life = newValue;
    	},
    	collide: function() {
  		  this.classList.add('collide');
		    setTimeout(function() {
		      this.classList.remove('collide');
		    }.bind(this), 1000);
		    return this;
    	},
    	explode: function(autoDestroy) {
    		this.life.current = 0;
    		this.animation.__start.call(this, 'explode', autoDestroy);
    		return this;
    	},
    	destroy: function(){
				if(this.parentNode){
					this.parentNode.removeChild(this);
				}
    	},
    	heal: function(amount){
    		if((this.life.current + amount) <= this.life.max){
    			this.life.current += amount;
    		}
    		return this;
    	},
    	hit: function(amount){
    		if(this.life.current > 0){
    			this.life.current -= amount;
	    		this.amount = amount;
	    		this.animation.__start.call(this, 'hit-animate');
    		}
    		return this;
    	},
    	setDead: function(){
    		this.async(function(){
    			this.$['entity-template'].classList.add('dead');
    		}, null, 500);
    		return this;
    	},
    	revive: function(info){
    		this.$['entity-template'].classList.remove('dead');
		    this.life = info.life;
		    this.name = info.playerInfo.name;
    		return this;
    	},
    	addState: function(state){
    		// this.$['states-container'].classList.add(state);
    	},
    	removeState: function(state){
    		// this.$['states-container'].classList.remove(state);
    	},
    	animation: {
    		__start: function(name, destroyAfterAnimationEnd, callback){
    			this.async(function() {
	    			this.$['states-container'].addEventListener('webkitAnimationEnd', function(){
	  					this.animation.__end.call(this, name, destroyAfterAnimationEnd, callback);
	    			}.bind(this), false);
	    			this.$['states-container'].classList.add(name);
					}, null, 0);
    		},
    		__end: function(name, destroyAfterAnimationEnd, callback){
		      this.$['states-container'].removeEventListener('webkitAnimationEnd', this.animation.__end.bind(this), false);
		      this.$['states-container'].classList.remove(name);
		      if(destroyAfterAnimationEnd){
		      	this.destroy();
		      }
		      if(callback && callback.call){
		      	callback.call(this);
		      }
    		}
    	},
    	created: function(){
    		this.debug = false;
    		this.avatar_is_uri = false;
    		try {
					entity = RPG.Factory[this.type]();
    		}
    		catch(e){
    			console.error('The entity type "'+this.type+'" is not valid. Here is the stack trace...');
    			console.trace();
    		}
    	}
    });
  </script>
</polymer-element>